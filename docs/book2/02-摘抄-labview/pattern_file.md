# 文件读写

## 二进制文件和文本文件

LabVIEW 文件读写相关的函数和 VI 主要在“编程 -\> 文件 I/O”函数选板上：

![images_2/z168.png](images_2/z168.png "文件 I/O 函数选板")

在这个函数选板上可以看到读写多种不同类型的文件的函数。这些不同类型的划分主要是按照数据在文件中的组织格式来区分的。如果我们先不考虑数据的组织格式，只考虑文件中的数据的内容，可以把文件分为两大基础类别：二进制文件和文本文件。二进制文件中，每个字节的数据用 U8 整数表示的话，可以是 0~255 之间的任何一个数，当然在文件中，这个字节并不一定是用来表示整数的，它可能是用来表示其它数据类型的。文本文件中的每个字节则不会是任何数值，它们只会是某些人眼可读的字符所对应的二进制数值。比如，文件中会有大小写字母、数字、标点、空格、换行符等。如果用文本编辑器打开，文本文件是可以被直接阅读的，而二进制文件里通常只能看到一堆乱码。

严谨的说，文本文件也是一种广义上的二进制文件，它在存储上也是一串二进制数。但我们这里比较的是狭义上的二进制文件（非文本）与文本文件的区别。

二进制文件直接把数据的原始格式写入硬盘，优点是数据占用空间小。但是二进制文件中可能包含各种长度的不同类型的数据，如果不知道一个二进制文件的格式，是无法知道里面存储的都是哪些数据的。二进制文件只能使用约定好的的程序或函数来读写；文本文件里面的数据都是人眼可以识别的字符串，优点是可以直接使用文本编辑器打开这类文件进行查看和编辑。

比如说，一个小数“38749.928398387799”，按照二进制格式保存一般需要占用 8 个字节（双精度浮点数），如果不要求那么精确 4 个字节（单精度浮点数）也行；而使用文本格式保存则至少需要 18 个字节，也就是这个字符串的长度，考虑到文本文件通常还要加入数据间的分隔符，以及很多辅助信息，存储同样的数据，文本文件占用的空间可能比二进制文件大几倍。

二进制文件不仅空间效率高，时间效率也高。本身文件小，读写时间就短。尤其是很多程序中，数据在内存中本来就是以二进制格式保存的，它们可以被直接写入二进制文件。如果保存成文本文件，还需要先把它们转换成字符串才能保存，非常影响速度。

综上所述，如果需要高速度，就使用二进制文件；如果需要操作方便就是用文本文件。如果追求极致的存储效率，不介意运行速度，还可以使用文件压缩函数，对存储的文件进行压缩。有些文件类型，采用了折中方案，单个文件内既包含二进制部分，也包含文本部分，比如采集到的数据使用二进制存储，而可能被直接查看的内容，如通道名、用户名等则使用文本格式存储。

我们先来看一下 LabVIEW 中最基本的文件读写如何使用。

### 二进制文件读写

二进制文件可以用于存储任何类型的数据，比如数组、簇等。但是我们在写入数据的时候，一定要记得数据类型都有哪些，是按照什么顺序写入的，在读取数据是必须按照同样的数据类型、同样的顺序把每一个写入的数据读出。如果我们拿到的是别人保存的一段二进制文件，不知道其中数据的格式，那么我们将无法从中读出正确的数据。

下图是一段典型的写二进制文件的程序，它在一个循环中保存了 10 个整数。

![images_2/z169.png](images_2/z169.png "写二进制文件")

程序首先调用“打开文件”函数，打开指定路径的文件。如果不给这个函数指定文件路径，程序运行时，它会弹出一个选择文件对话框，要求用户选择一个文件。这个对话框可供设置的选项非常有限，后文会介绍一个功能更强大的选择文件对话框。其实，“写入二进制文件”和“读取二进制文件”如果没有指定文件路径或句柄，也可以弹出选择文件对话框，但一般不会在程序里这样用。

“打开文件”可以设置新建、替换等操作。一般来说，如果需要读取或者修改目标文件，也就说目标文件必须存在，则应该选择“打开”操作，这样，“打开文件”若找不到目标文件会报错；如果需要写一个新文件，则应该选择“新建”操作，这样，“打开文件”若发现目标文件已存在则报错；如果确定目标文件存在，但是要完全替换目标文件中的内容，则应该选择“替换”操作。示例程序使用了“替换或新建”操作，表示如果文件不存在则新建一个，若已存在则替换其内容。

“打开文件”还可以设置文件的访问权限：只读、只写、读写。对于不需要进行修改的文件，可以把打开权限设置为只读，以确保后续程序不会无意间修改文件内容。

“打开文件”函数会输出一个文件句柄，这个句柄就代表了目标文件，后续程序需要用它来指定对哪个文件进行读、写或关闭。

程序中的“写入二进制文件”函数会把输入“数据”参数的数据都存入文件。“数据”参数默认是变体类型，但它可以接收几乎所有的数据类型，任何数据都可以被以二进制形式存入文件。程序中按次序从 0 至 9 写入了 10 个整数。“写入二进制文件”另一个参数是“字节顺序”，可以指定按照什么顺序保存一个数据的每个字节。比如一个 I32 整数有 4 个字节，那么这 4 个字节按什么顺序摆放呢？是高位在前还是低位在前？目前，主流 CPU 在处理数据的时候，都是按照“小端”顺序处理数据的，也就是高位数据保存在内存的高地址中；但是网络传输协议却大多是采用的“大端”，也就是高位数据保存在内存的低地址中。这两种设置没有明显的优劣之分，只要保证读写时采用一致的设置即可。

存入数据后，一定要记得关闭文件。出于效率考虑，文件写入函数通常不会把数据直接写入硬盘，而是会先把数据放在缓存中，只有关闭文件才能确保所有缓存中的数据被写入硬盘。

我们可以试着用文本编辑器（比如 notepad）查看一下写入文件的数据是什么样的。笔者直接在命令行终端打显示了刚刚生成的 test.data 文件的内容，但是只能看到一些乱码：

![images_2/z170.png](images_2/z170.png "查看二进制文件")

要还原文件中的数据，只能再编写一段程序，把数据读出来。读取二进制文件的过程与写入十分类似：

![images_2/z171.png](images_2/z171.png "读取二进制文件")

在这个程序里我们使用了一个“文件对话框” [Express VI](measurement_express_vi) 来选取目标文件。Express VI 与普通 VI 不太一样，它除了输入输出参数，通常还有一些配置参数。把“文件对话框”拖到程序框图上的时候，或者在程序框图上双击这个 Express VI，就会弹出它的配置对话框：

![images_2/z172.png](images_2/z172.png "配置文件对话框")

在“配置文件对话框”上，我们选择了只需要单个文件，并且必须是一个已存在的文件。除了这几个基础的配置信息，我们还需要通过输入参数的方式，告诉这个 VI 我们需要选择的文件后缀名是 ".data"，初始路径在 "/tmp"，并且选择文件的对话矿上还需要有一句提示：“Select the data file”。配置好这些参数，运行程序，它就会弹出选择文件对话框：

![images_2/z173.png](images_2/z173.png "选择文件对话框")

在这里选则目标文件，点击确定按钮，所选择的文件的路径会从“文件对话框” VI 的“所选路径”参数输出。如果用户在选择文件对话框中点击了“取消”按钮，程序应该避免运行后续的读文件程序，以免程序出错。因此，示例程序检查了“文件对话框” VI 的“取消”输出，如果其值为真，则什么都不做。

“读取二进制文件”函数必须设置读取数据的类型。二进制文件本身没有数据的类型信息，这里指定的数据类型必须与写文件时写入的数据类型一致。读数据时，我们可以像写数据程序一样用一个循环来读取数据。不过“读取二进制文件”中直接就可以设置读取数据的数量。如果我们设置数量为 10，“读取二进制文件”函数就会一次读取 10 个数据出来。如果把这个参数设置为 -1，函数会一次读出后续所有的数据。

虽然在演示程序中，只保存了 10 个同样为整数类型的数据，但实际上，我们也可以把不同类型的数据都存放在同一个文件中的。比如先写入两个整数，再写入三个布尔型数据，最后放入一个簇类型数据。只要读取文件时保证数据类型和顺序与写入时一模一样就可以读出正确的数据。

:::info

这里请读者思考一个问题。上文写二进制文件的示例中，连续写入了 10 个整数。如果程序换一种做法：一次写入一个长度为 10 的整数数组。假设对应的整数数值都是相同的，这两种方法写入二进制文件的数据是不是相同的呢？

:::

### 文本文件读写

与操作二进制文件极其类似，LabVIEW 还提供了“写入文本文件”和“读取文本文件”函数。在使用“写入文本文件”函数把字符串写入文件时，它会把字符串的内容写入文件。比如下面的程序：

![images_2/z177.png](images_2/z177.png "写入字符串文件")

示例程序首先调用“生成临时文件路径” VI 生成了一个临时文件的路径。需要注意的是，它只是生成了一个路径，这个路径对应的文件还不存在。在做测试的时候，我们经常需要把数据参数保存在一个临时文件中，一段时间之后，就可以将其丢弃了。这种情况使用“生成临时文件路径” VI 就特别方便，因为它不用自己费脑筋去给临时文件起名。并且，它生成的临时文件是在系统的临时文件夹中的，操作系统会定时清理临时文件夹中的文件，我们也不用担心生成的临时文件会占用太多系统空间。

查看生成的文件，里面只有可读的文本文字：

![images_2/z178.png](images_2/z178.png "写入字符串文件")

上面示例程序的后半部分又把数据从文件中读取出来了。因为这里没有关闭文件后再打开的过程，在读文件之前需要调用“设置文件位置”函数，把文件当前位置设置到文件的起始位置。程序每读或写一个数据，文件的当前位置都会向后移动一个数据的长度，如果在写完数据之后，需要把数据再读回来，则需要把文件当前位置重置到文件开头。对于一个大文件，如果我们只需要读取其中的某一部分内容，也可以使用“设置文件位置”函数把当前位置移动到所需要的地方，再读取数据。

文本通常会被分成一行一行的，所以“写入文本文件”除了支持字符串数据类型的输入，还支持字符串数组作为输入，数组中的每个元素会被作为一行写入文件。“读取文本文件”函数也可把读取的文本按照字符串数组方式输出。在“读取文本文件函数”的右键菜单上选中“读取行”，这时候，这个函数就会按照行来读取文件，默认每次读一行。再把读取数量设置为 -1,函数就会读出文件中所有的行：

![images_2/z180.png](images_2/z180.png "写入字符串数组")

如果已经按照字符串格式读出了数据，也可以调用 LabVIEW 中的字符串处理函数（Delimited String to 1D String Array.vi）把它按照行转换为字符串数组。下图中的程序与上图中的程序是等效的：

![images_2/z179.png](images_2/z179.png "写入字符串数组")

读者可能已经注意到了，“写入文本文件”和“读取文本文件”函数的右键菜单都有一项叫做“Convert EOL”（转换换行符），这个设置只在 Windows 系统上有效。在 Windows 操作系统的文本文件中，每行结尾默认是两个字符“回车+换行(CR+LF)”，即 "\r\n"；Unix 和 Linux 系统的文本里，每行结尾默认是“换行 LF（\n）”；苹果电脑系统的文本里，每行结尾默认是“回车 CR 即'\r'”。目前，网上下载的文本文件，尤其是各种文本编程语言的源代码，多是采用 Linux 系统的换行方式。如果设置了“转换换行符”，“写入文本文件”和“读取文本文件”函数在 Windows 系统下会自动把源文档中每行之间的分隔符都替换成 "\r\n"。


### 相通的两种格式

既然文本文件只是一种特殊的二进制文件，那么是不是直接使用二进制文件函数也可以操作文本文件？只要把字符串数据传递给“写入二进制文件”就可以生成文本文件了？我们用下面的程序验证一下：

![images_2/z174.png](images_2/z174.png "写入字符串二进制文件")

程序调用“写入二进制文件”把字符串 "abcdef" 写入了临时文件中。如果使用文本编辑器打开这个生成的文件，会发现 "abcdef" 确实被写入了文件，但是在这几个字符之前还有一些乱码：

![images_2/z175.png](images_2/z175.png "写入字符串二进制文件")

为了更清楚的查看这几个乱码是什么，上图中的示例程序在保存了字符串之后，又按照 U8 整数的格式把整个文件中所有的数据读了出来。使用 U8 类型是因为它占用的空间恰好是一个字节，这样我们可以把文件中所有的字节按照顺序读取，并显示出每个字节的数据。程序运行结果如下：

![images_2/z176.png](images_2/z176.png "写入字符串二进制文件")

原来，“写入二进制文件”在写入字符串数据时，不但把字符串的内容写入了文件，还在字符串内容之前写入了一个 U32 类型整数，表示字符串的长度。也只有这样，“读取二进制文件”函数在读取字符串数据时才知道应该读取多少个字节。文本文件应当只包含字符串的内容，所以，我们可以先把字符串转换成 U8 数组，在把数组的每个元素写入文件，这样生成的文件就是一个文本文件了：

![images_2/z181.png](images_2/z181.png "写入二进制文件函数生成文本文件")

采用同样的原理，我们也可以调用“写入文本文件”函数来生成一个二进制文件。在[“字符串”](data_string)一节中，我们介绍了“平化”的概念，当数据被写入二进制文件时，就是一个平化的过程。所以，如果我们先把某个数据平化成字符串，再调用“写入文本文件”函数写入文件，其结果与直接调用“写入二进制文件”函数把数据写入文件是完全相同的，比如下图中的两种写书数据方式是完全等效的：

![images_2/z182.png](images_2/z182.png "写入文本文件函数生成二进制文件")



## LabVIEW 中常用的文件格式

使用最基本的二进制和文本文件，用户可以任意组织其中的数据的结构。这样固然灵活，但是不利于交流，其他人未必了解你的文件格式，想要正确读写你的文件可能不那么便利。好在人们已经定义了数不清的各种文件格式，每种文件格式都定义好了其内部数据的组织方式。很多文件的格式规范都是公开的，如果按照已某个规范创建出一个文件，就不必担心其它人无法正确理解这个文件了。

在“文件 I/O”函数选板上就可以直观的看到 LabVIEW 支持的一些文件类型，比如电子表格格式文件、测量文件、配置文件、TDM/TDMS 文件、XML 文件、波形文件等。操作这些类型的文件与操作最基本的二进制和文本文件是类似的，它们都会有打开、读、写、关闭几个基本操作。有些类型文件只保留了读和写函数，把打开、关闭的操作合并到读、写函数里了。所以，最关键的问题可能还是应该如何选择适合项目类型的文件。

### 电子表格文件

电子表格文件是一种文本格式的文件，专用于二维数组数据的读写。二维数组数据（表格）是一种非常常见的数据格式，比如，一个班级的考试成绩就可以被做成一个表格，表格中每个单元是一个成绩数据；每行代表一名学生；每列代表一门功课。电子表格文件根据分隔符的不同，有两种最常见的格式，一种是用逗号 "," 分隔一行中的每个数据，通常用 ".csv" 作为文件名后缀；一种是用制表符 "\t" 分隔一行中的每个数据，通常用 ".tsv" 作为文件名后缀。用户也可以任意自定义分隔符和文件名后缀名，但是使用已有的规范通用性会更好，容易被其它软件识别。

微软的 Excel 是最常用的一款处理表格数据的软件。Excel 以及其它类似软件，比如 Google Sheets、WPS 办公软件等都可以读写 .csv 或 .tsv 文件。如果需要在这些软件和 LabVIEW 之间共享数据，使用电子表格文件是一个非常好的方案。

电子表格文件的读写都比较简单，下图是一个写电子表格的示例：

![images_2/z183.png](images_2/z183.png "写入电子表格文件")

不论输入的数组元素是那种类型，最终都是以文本格式存入文件，所以写入时可能需要设置数据写入时的格式，使得文件中的数据更容易阅读。可以参考 [字符串数据](data_string) 一节中关于字符串格式化的设置。

程序写入文件的数据如下：

![images_2/z184.png](images_2/z184.png "写入电子表格文件")

下图是一个在网上找到的开源数据文件，weight_height.csv

![images_2/z185.png](images_2/z185.png "weight_height.csv")

可以很明显的看出，这个文件中的数据有 3 列，分别表示性别、身高和体重。使用下图中的程序可以把文件中的数据读出并显示：

![images_2/image90.png](images_2/image90.png "读入并整理身高体重数据")

“读取电子表格文件”是一个 [多态 VI](oop_generic)，点击它下面的数据类型选择菜单，可以看到它能够读入的三种数据类型：实数 DBL，整数 I64 和字符串 String。需要读取的文件中既有字符串数据（第一列，性别），也有实数数据（第二三列，身高和体重）。如果选择按照实数数据类型读入，那么输出的结果会是一个二维实数数组，它会忽略源文件中的所有字符串数据。所以我们这里只能按照字符串读出所有的数据，再自己把身高体重转换成实数。

这个 csv 文件是使用逗号做分隔符的，所以在读取的时候必须设置使用 "," 分隔数据，否则这个 VI 会默认用制表符去分隔数据。

很多电子表格文件的第一行都不是数据，而是每列数据的名称。只要在读取文件后，保留所需要的数据即可。

程序运行结果如下图所示：

![images_2/image92.png](images_2/image92.png "使用 XY 图形控件显示身高体重数据")

关于数据的显示部分，可以参考 [图形化显示数据](data_graph) 一节。


### 配置文件

配置文件也被称为 INI 文件，因为这类文件通常以 .ini 为后缀名。INI 是英文 Initialization （初始化）的缩写。 ini 文件专用于专用于保存程序的配置信息，比如记录程序界面尺寸、位置，之前打开过的文件等等。有了这些记录，程序每次启动后才能恢复到上一次关闭时的状态，这也是 INI 文件名字的由来。Windows 系统下的 LabVIEW 本身就带有一个 INI 文件，它是与 LabVIEW.exe 文件同文件夹下的 LabVIEW.ini 文件。INI 文件是一种文本文件，所以读者可以使用文本编辑器打开 LabVIEW.ini，看看里面有什么内容。

比如，读者会看到类似下面的一些条目：

```ini
[LabVIEW]
IconEditor.TextFont="LabVIEW Application"
IconEditor.TextSize=00000009
```

上面示例列只截取了 LabVIEW.ini 文件中的两条，它们分别表示 LabVIEW 图标编辑器中使用的字体和字号。如果用户在图标编辑器里改变了字体和字号，这些更改都会被记录在这个 INI 文件中，即便在重新启动 LabVIEW 之后，LabVIEW 也会记住用户的设置。

在示例中，中括号代表一个段落的开始，一个 INI 文件中可以有多个段落。中括号中的文字代表段落的名称，同一个文件中每个段落的名必须是唯一的。中括号下面的行，直到下一个中括号之前，都是这个段落的内容。内容中每一行必须是一对键值：等号左边表示一个设置的名称，等号右边是这个设置的值。在同一个段落内，键的名称必须是唯一的，不同的段落可以有同样的键名。值可以是数值类型或字符串类型的数据。有时候也可能会看到使用英文分号 ";" 起始的行。分号是 INI 文件的注释符，如果一行以分号开头，这一行就不会有实际功能。

下面是一个典型 INI 文件的示例：

```ini
[section_one]
key1=1
key2="some string"

[section_2]
key1=2.5
;下面这行没用
;key_five=7.99
```

读写 INI 文件先要打开文件，然后读写，最后关闭。这与读写文本文件和二进制文件的过程非常类似。INI 文件的读写 VI 都是 [多态 VI](oop_generic)，它们支持六种基本数据类型的读写，包括布尔、双精度、I32、路径、字符串、和 U32 数据类型。无论那种数据类型，都需要指定读写的段落名可键名，写数据时，如果段落或键不存在，文件会新建一个相应的段落和键；读数据时，如果段落或键不存在则会返回用户指定的默认值。

下图是一段写入 INI 文件的程序：

![images_2/z187.png](images_2/z187.png "写入 INI 文件")

程序首先拿到当前 VI 的路径，然后去掉文件名，只保留路径，也就是这个程序所在的文件夹的路径。然后构造了一个新的路径，指向当前 VI 同文件夹下的 test.ini 文件。之后调用“打开配置数据” VI 来打开这个 INI 文件。之后再调用“写入键” VI 写入了几种不同类型的数据。这个程序还调用了“删除键”和“删除段” VI，删除了刚才写入的一些数据，被删除的段落和键值将不会出现在文件中。程序最后调用“关闭配置数据” VI 关闭文件。文件是在关闭时才真正被写入文件的，也就是说，如果只调用“写入键”而不关闭文件，那么硬盘上文件的内容是不会变的。

如果打开的 INI 文件原本就有一些内容，那么“写入键”会覆盖那个同段落、同键名内的数据；如果某个键没有被重新写入或删除，则它的内容不会变化。

当写入字符串数据时，VI 还有一项设置：“write raw string?”（写入原始数据），一般使用默认值即可；这时，写入 VI 会自动对不可显示的字符比如回车符等进行编码，把它们编程可以显示的形式。只有在极个别的情况，比如写入的 INI 文件要给 LabVIEW 之外的程序使用时，才可能要求对字符串不进行编码。

运行上面程序，产生的 INI 文件如下：

![images_2/z188.png](images_2/z188.png "写入 INI 文件")

可以看到 key 4 对应的字符串数据中，回车符被编码成了 "\0A"。 文件中还有一些原本就存在的段落和键值，没有被改动。

我们无法把复杂类型的数据，比如数组，或簇直接传递给“写入键” VI。但也是有办法把这样的数据保存到 INI 文件中的，比如 labVIEW.ini 文件中就有这样的键值，键 "RecentFiles.pathList"  记录了 LabVIEW 最近打开过的十个 VI 的路径。它原本应该是一个路径的数组，LabVIEW 为了把它写入 INI 文件，把数组数据转换成了一个字符串，在字符串中用 ":" 分隔每个 VI 的路径。我们自己在编写程序的时候，可以仿照 LabVIEW.ini 的方法，把复杂数据转换成自定义格式的字符串。可以参考上文“相通的两种格式”这一段，使用[“字符串”](data_string)一节中介绍的“平化”函数，把数据平化成字符串，再保存至 INI 文件。

读取 INI 文件与写入相似，下图是读取 LabVIEW.ini 文件的程序：

![images_2/z189.png](images_2/z189.png "读取 INI 文件")

程序首先调用文件对话框找到一个文件。在 Linux 系统下，配置文件的后缀名是 .conf。然后程序打开了这个配置文件，再调用“获取键名” VI 得到了 "LabVIEW" 段落下的所有键名。之后逐个读出每个键的值。“读取键”也是一个多态 VI，它支持的数据类型与“写入键” VI 相同。但是因为这里我们使用了一个循环来读取数据，没有区分它们的数据类型，所以就用了字符串的形式来读取所有的数据。因为 INI 是一种文本文件，所以，任何内容也都可以被当做字符串读出。程序运行结果如下，它是笔者的 LabVIEW 环境的部分设置信息：

![images_2/z190.png](images_2/z190.png "读取 LabVIEW.ini 中的部分数据")

配置文件的读写效率是非常低。一般，应用程序的配置信息不会太多，使用配置文件保存这些信息不会有问题。但如果是程序采集到的数据，或者分析数据的结果，通常数据量会比较大，就不适合用配置文件来存储。

### 。。。
* LabVIEW 测量文件不是一种文件类型，而是一套 [Express VI](measurement_express_vi)。它可以把测量数据读写到几种不同类型的文件中。如果编写的是一个数据采集，或者测试程序，并且程序的数据采集部分也是使用 Express VI 编写的，那么使用这一套 Express VI 读写文件再合适不过了。

* TDM 和 TDMS 两种数据格式非常类似。TDM （technical data management） 只能用在 Windows 操作系统下，它可以把硬件采集到的数据以二进制格式保存在后缀名为 .tdx 的文件中，同时在同名的 .tdm 文件中以文本格式记录一些相关信息，比如通道名、用户名等。TDMS （TDM streaming） 则是把所有的二进制和文本数据都合并进了一个 .tdms 文件。当直接记录设备采集的数据时，可以采用 TDMS 文件存储。
* XML，和 JSON 都是文本格式的文件，它们为保存的数据添加了标签，用于为数据添加说明信息。如果需要保存的数据有比较复杂的结构，并且希望可以直接在文本编辑器中查看数据，那么采用 XML 或者 JSON 文件格式。
* 波形文件顾名思义，专用于保存波形类型的数据。波形文件是一种特殊的 LabVIEW “数据记录文件”。数据记录文件可以以二进制数据根式保存任何 LabVIEW 程序中的数据。如果仅仅是想把某个数据记录下来，一遍下次打开程序时继续使用，那么就可以采用数据记录文件。数据记录文件虽然使用方便，但由于它的格式时二进制的，我们无法直接在文本编辑器中直接查看。






## 练习

* 
